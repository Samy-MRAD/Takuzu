N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 1
gamma <- 2
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x == y, 1, 0)
# Trajectoire
tr_pi2 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepot n'est pas vide initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i-1] - D[i])
A[i] <- M*ind(X[i],0)
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi2 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi2(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données statistiques
G <- mc_pi2(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 1
gamma <- 2
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x < y, 1, 0)
# Trajectoire
tr_pi3 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepôt est plein initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i] - D[i])
A[i] <- ind(X[i],M)
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi3 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi3(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données stats
G <- mc_pi3(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D=3
alpha <- 1
gamma <- 2
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x <= y, 1, 0)
tr_pi4 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepôt est au dessus du seuil initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
A[i-1] <- (M-X[i-1])*ind(X[i-1],3)
X[i] <- max(0, X[i-1] + A[i-1] - D[i])
r[i] <- -alpha*A[i-1] - gamma*max(0,D[i]-X[i]-A[i-1])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi4 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi4(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données statistiques
G <- mc_pi4(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 0
gamma <- 2
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x == y, 1, 0)
# Trajectoire
tr_pi2 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepot n'est pas vide initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i-1] - D[i])
A[i] <- M*ind(X[i],0)
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi2 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi2(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données statistiques
G <- mc_pi2(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 0
gamma <- 2
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x < y, 1, 0)
# Trajectoire
tr_pi3 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepôt est plein initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i] - D[i])
A[i] <- ind(X[i],M)
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi3 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi3(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données stats
G <- mc_pi3(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D=3
alpha <- 0
gamma <- 2
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x <= y, 1, 0)
tr_pi4 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepôt est au dessus du seuil initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
A[i-1] <- (M-X[i-1])*ind(X[i-1],3)
X[i] <- max(0, X[i-1] + A[i-1] - D[i])
r[i] <- -alpha*A[i-1] - gamma*max(0,D[i]-X[i]-A[i-1])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi4 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi4(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données statistiques
G <- mc_pi4(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D=3
alpha <- 1
gamma <- 0
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x <= y, 1, 0)
tr_pi4 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepôt est au dessus du seuil initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
A[i-1] <- (M-X[i-1])*ind(X[i-1],3)
X[i] <- max(0, X[i-1] + A[i-1] - D[i])
r[i] <- -alpha*A[i-1] - gamma*max(0,D[i]-X[i]-A[i-1])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi4 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi4(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données statistiques
G <- mc_pi4(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 0
gamma <- 2
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x < y, 1, 0)
# Trajectoire
tr_pi3 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepôt est plein initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i] - D[i])
A[i] <- ind(X[i],M)
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi3 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi3(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données stats
G <- mc_pi3(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 1
gamma <- 0
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x < y, 1, 0)
# Trajectoire
tr_pi3 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepôt est plein initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i] - D[i])
A[i] <- ind(X[i],M)
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi3 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi3(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données stats
G <- mc_pi3(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 1
gamma <- 0
nsim <- 10000
# Fonction qui décrit une trajectoire
tr_pi1 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0
D=rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i-1] - D[i])
A[i] <- M - X[i] # restockage à plei
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi1 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi1(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données stats
G <- mc_pi1(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
print(gain_moyen) # Gain moyen sur 10000 simulations
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
N <- 20
M <- 9
x <- 9
param_D <- 3
alpha <- 1
gamma <- 0
nsim <- 10000
# Indicatrice
ind <- function(x,y) ifelse(x == y, 1, 0)
# Trajectoire
tr_pi2 <- function(M, N, param_D, alpha, gamma, x) {
# Initialisation
X <- numeric(N+1)
A <- numeric(N+1)
r <- numeric(N+1)
X[1] <- x
A[1] <- 0 # l'entrepot n'est pas vide initialement
D <- rpois(21,param_D)
# Boucle
for (i in (2:(N+1))) {
X[i] <- max(0, X[i-1] + A[i-1] - D[i])
A[i] <- M*ind(X[i],0)
r[i] <- -alpha*A[i] - gamma*max(0,D[i]-X[i]-A[i])
}
gain <- sum(r)
return(gain)
}
# Monte Carlo
mc_pi2 <- function(nsim, M, N, param_D, alpha, gamma, x) {
G <- numeric(nsim)
for (i in (1:nsim)) {
G[i] <- tr_pi2(M, N, param_D, alpha, gamma, x)
}
return(G)
}
# Récupération des données statistiques
G <- mc_pi2(nsim, M, N, param_D, alpha, gamma, x)
gain_moyen <- sum(G)/nsim
var <- var(G)
# Intervalle de confiance
borne_inf <- gain_moyen - 1.96*sqrt(var(G)/nsim)
borne_sup <- gain_moyen + 1.96*sqrt(var(G)/nsim)
print(gain_moyen)
cat("Le résultat est compris entre", borne_inf, "et", borne_sup, "avec 95% de chances.")
# Paramètres
n <- 1000  # Taille de l'échantillon
N <- 10000 # Nombre de simulations pour le max
set.seed(123)
M_n <- replicate(N, max(rcauchy(n,0,1)))
# Normalisation correcte pour une loi de Cauchy
b_n <- n
a_n <- pi
Y_n <- M_n*a_n / b_n  # Centrage-réduction
# Histogramme
hist(Y_n, breaks = 50000, probability = TRUE,
col = "lightblue", border = "white",
main = paste("Max de", n, "lois de Cauchy"), ylab="Densité",
xlab = "Y_n",ylim = c(0,0.6), xlim = c(0, 10))
# Densité limite de Fréchet (alpha = 1)
alpha <- 1
frechet <- function(x) alpha * exp(-x^(-alpha)) * x^(-1 - alpha)
curve(frechet, from = 0, to = 10, col = "red", lwd = 2, add = TRUE)
# Légende
legend("topright", legend = c("Simulation", "Densité théorique : Fréchet(1)"),
fill = c("lightblue", NA), border = c("white", NA),
lty = c(NA, 1), col = c(NA, "red"), lwd = c(NA, 2))
library(shiny); runApp('C:/Users/fabia/Takuzu/Matrice8x8.R')
